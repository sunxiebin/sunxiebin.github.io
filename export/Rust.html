<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-04-29 Mon 16:48 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RUST-LANUAGE</title>
<meta name="author" content="sunxiebin" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="../org.css"/>

<script src="../org-info.js">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
// @license-end
</script>

<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
// @license-end
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">RUST-LANUAGE</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org73abe9c">1. Rust language</a>
<ul>
<li><a href="#org12729fc">1.1. 1. example-1</a>
<ul>
<li><a href="#org8154562">1.1.1. first name</a></li>
<li><a href="#org32c7f82">1.1.2. <span class="todo TODO">TODO</span> Task-1:I must to be know move abstaction  <span class="timestamp-wrapper"><span class="timestamp">&lt;2024-03-08 Fri&gt;</span></span></a></li>
</ul>
</li>
<li><a href="#orgd97bd52">1.2. 2. move</a>
<ul>
<li><a href="#org31058d9">1.2.1. image</a></li>
</ul>
</li>
<li><a href="#org0504f76">1.3. 3. refenrence and derefenrence</a>
<ul>
<li><a href="#org2420cb1">1.3.1. lifetime</a></li>
<li><a href="#orgbb31cdc">1.3.2. smarts points</a></li>
</ul>
</li>
<li><a href="#org9960eac">1.4. 3. expression</a></li>
<li><a href="#org3b36dc8">1.5. 4. structure</a>
<ul>
<li><a href="#orgf5b03a8">1.5.1. three</a></li>
<li><a href="#org9819139">1.5.2. struct 编译器会自动调用引用和解引用</a></li>
<li><a href="#org1be94ab">1.5.3. 考虑多struct的相互调用</a></li>
<li><a href="#org0ea6dc9">1.5.4. abstracts</a></li>
<li><a href="#org0e1a8ba">1.5.5. generic type 泛型</a></li>
<li><a href="#org62d82f2">1.5.6. 单态化</a></li>
</ul>
</li>
<li><a href="#org979e1f0">1.6. 5. trait</a>
<ul>
<li><a href="#org277b966">1.6.1. 函数的重载</a></li>
<li><a href="#org352d4a3">1.6.2. 特征作为函数参数</a></li>
<li><a href="#org8ebdcd6">1.6.3. 生命周期</a></li>
</ul>
</li>
<li><a href="#org1463ef7">1.7. third party</a></li>
<li><a href="#orgc3a9af5">1.8. <span class="todo TODO">TODO</span> todo <span class="timestamp-wrapper"><span class="timestamp">&lt;2024-03-01 Fri&gt;</span></span></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org73abe9c" class="outline-2">
<h2 id="org73abe9c"><span class="section-number-2">1.</span> Rust language</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org12729fc" class="outline-3">
<h3 id="org12729fc"><span class="section-number-3">1.1.</span> 1. example-1</h3>
<div class="outline-text-3" id="text-1-1">
<p>
使用的插件是ob-rust,底层使用了rust-script命令。
</p>
<div class="org-src-container">
<pre class="src src-rust">fn main(){
 let mut v:Vec&lt;i32&gt;=Vec::new();
  v.push(10);
  let one:Option&lt;&amp;i32&gt;=v.get(0);
      match one {
      Some(x)=&gt;println!("result:{x}"),
          None  =&gt; println!("None"),
   }
  }
</pre>
</div>

<pre class="example">
result:10
</pre>

<div class="org-src-container">
<pre class="src src-rust">fn main(){
   let mut a:i32=1;
   loop {
      a+=1;
       println!("a:{}",a);
       if a== 5{
        let b=1;   
        break;
       }
      println!("b:{}",b); 
   }
}
</pre>
</div>
</div>
<div id="outline-container-org8154562" class="outline-4">
<h4 id="org8154562"><span class="section-number-4">1.1.1.</span> first name</h4>
</div>
<div id="outline-container-org32c7f82" class="outline-4">
<h4 id="org32c7f82"><span class="section-number-4">1.1.2.</span> <span class="todo TODO">TODO</span> Task-1:I must to be know move abstaction  <span class="timestamp-wrapper"><span class="timestamp">&lt;2024-03-08 Fri&gt;</span></span></h4>
<div class="outline-text-4" id="text-1-1-2">
</div>
</div>
</div>

<div id="outline-container-orgd97bd52" class="outline-3">
<h3 id="orgd97bd52"><span class="section-number-3">1.2.</span> 2. move</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org31058d9" class="outline-4">
<h4 id="org31058d9"><span class="section-number-4">1.2.1.</span> image</h4>
<div class="outline-text-4" id="text-1-2-1">

<div id="org977f197" class="figure">
<p><img src="./image/a.jpeg" alt="a_image">
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org0504f76" class="outline-3">
<h3 id="org0504f76"><span class="section-number-3">1.3.</span> 3. refenrence and derefenrence</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<a id="org0058f0c"></a>example
</p>
<div class="org-src-container">
<pre class="src src-rust">fn main() {
    let x = 66;
    let y = &amp;x; //  操作符 ‘=’ 的意义，
    assert_eq!(5, x);
    assert_eq!(5, *y);
    println!("this is {}",y);

}  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C">#include&lt;stdio.h&gt;  
  int main(){
    int x=5;
    int *y;
    y=&amp;x;
   printf("%p",y);
   return 0;
 }
</pre>
</div>
</div>

<div id="outline-container-org2420cb1" class="outline-4">
<h4 id="org2420cb1"><span class="section-number-4">1.3.1.</span> lifetime</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
借用的生命周期
借用是为了防止所有权的转移，借用的作用域和自身的属性相关，自身属性分为不可变和可变。在一个{}作用域中
存在“只能有一个可变引用，要么可以有多个不可变引用，但不能同时有可变和不可变引用”，如果两者在一个{}
同时存在，编译器不会通过，变相的显示引用作用域的缩短，这样做是为了避免数据竞争。
 lifttime is only in the complie period.
 every type in Rust has a lifetime
</p>
<div class="org-src-container">
<pre class="src src-rust">
  fn main(){

//      fn some&lt;'a,'b&gt; (x:&amp;'a str ,y:&amp;'b str )-&gt;&amp;'b str{
//		y
  //    }

    let mut x = 5; // 可变变量

    // 不可变借用
    let y = &amp;x;
    println!("不可变借用：{}", y);

    // 可变借用
    let z = &amp;mut x;
    *z += 1;
    println!("可变借用：{}", z);
   // println!("不可变借用：{}", y);
  }
</pre>
</div>
<p>
所有权的转移，还要分两种，一种是实现clone特征，一种没有实现的。没有实现就是移动。实现了就是复制。
</p>
<div class="org-src-container">
<pre class="src src-rust">fn main(){
    let x=String::from("hello,world");
    add(x);
    //let y=&amp;x;
   println!("{:p}",&amp;x);
}
fn add(x:String){
    println!("{:p}",&amp;x);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb31cdc" class="outline-4">
<h4 id="orgbb31cdc"><span class="section-number-4">1.3.2.</span> smarts points</h4>
</div>
</div>
<div id="outline-container-org9960eac" class="outline-3">
<h3 id="org9960eac"><span class="section-number-3">1.4.</span> 3. expression</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">
<pre class="src src-rust">
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b36dc8" class="outline-3">
<h3 id="org3b36dc8"><span class="section-number-3">1.5.</span> 4. structure</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orgf5b03a8" class="outline-4">
<h4 id="orgf5b03a8"><span class="section-number-4">1.5.1.</span> three</h4>
<div class="outline-text-4" id="text-1-5-1">
<ol class="org-ol">
<li>命名结构体</li>
<li>元祖结构体</li>
<li>单元结构体</li>
</ol>
</div>
</div>
<div id="outline-container-org9819139" class="outline-4">
<h4 id="org9819139"><span class="section-number-4">1.5.2.</span> struct 编译器会自动调用引用和解引用</h4>
<div class="outline-text-4" id="text-1-5-2">
<div class="org-src-container">
<pre class="src src-rust">struct Some{
  w:u32,
  h:u32,
} // 定义数据
impl Some{
 fn some(&amp;self)-&gt;u32{
 return  self.w*self.h;
}	}//定义方法
  fn main(){
   let s= Some{
    w:21,
    h:32,
   };//实例化
 println!("the area of the some is {} squre pixels ",s.some());//调用
   }
</pre>
</div>
</div>
</div>

<div id="outline-container-org1be94ab" class="outline-4">
<h4 id="org1be94ab"><span class="section-number-4">1.5.3.</span> 考虑多struct的相互调用</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
struct A实例关联struct B 时 
</p>
</div>
</div>


<div id="outline-container-org0ea6dc9" class="outline-4">
<h4 id="org0ea6dc9"><span class="section-number-4">1.5.4.</span> abstracts</h4>
</div>
<div id="outline-container-org0e1a8ba" class="outline-4">
<h4 id="org0e1a8ba"><span class="section-number-4">1.5.5.</span> generic type 泛型</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
concrete type(具体类型/动态类型)
</p>

<p>
消除重复，函数重复，包括签名重复和内容重复。
类似C++的泛型
</p>

<p>
使用单态化不会影响性能。
</p>
</div>
</div>


<div id="outline-container-org62d82f2" class="outline-4">
<h4 id="org62d82f2"><span class="section-number-4">1.5.6.</span> 单态化</h4>
<div class="outline-text-4" id="text-1-5-6">
<ol class="org-ol">
<li>其实就是把编译时，生成相应的重复代码。</li>
<li>这样坏处，自然带来编译后代码冗余。</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org979e1f0" class="outline-3">
<h3 id="org979e1f0"><span class="section-number-3">1.6.</span> 5. trait</h3>
<div class="outline-text-3" id="text-1-6">
<p>
A type’s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call
the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of
behaviors necessary to accomplish some purpose.
</p>

<p>
trait 是指特征。是指相同行为的抽象。
实现语法：
</p>
<pre class="example" id="orga80ce74">

pub trait ${trait_name} {
   fn ${function_name}-&gt; style;
}
impl ... for .. #这个语法其实挺口语化的，为类型实现特征。
</pre>

<p>
define-&gt;impl-&gt;call
</p>
<div class="org-src-container">
<pre class="src src-rust">fn main(){
 let person_one=Person{name:"sunxiebin".to_string(),};
 let dog_one=Dog{name:"xiaohuang".to_string(),};
 person_one.run();
 dog_one.run();
}
pub trait Run{
   fn run(&amp;self);
}
pub struct Person{
 pub name:String,
}
impl Run for Person{
  fn run(&amp;self){
    println!("{} begin to run",self.name);
  }
}
pub struct Dog{
 pub name:String,
}
impl Run for Dog{
    fn run(&amp;self){
        println!("{} begin to run",self.name);
    }
}

</pre>
</div>
</div>


<div id="outline-container-org277b966" class="outline-4">
<h4 id="org277b966"><span class="section-number-4">1.6.1.</span> 函数的重载</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
明显特征的默认函数既然被重载了，推理出特征的实现的作用域已经拓展到新的作用域。
</p>
</div>
</div>
<div id="outline-container-org352d4a3" class="outline-4">
<h4 id="org352d4a3"><span class="section-number-4">1.6.2.</span> 特征作为函数参数</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
之前提到了特征是行为的抽象，使得行为名词化。
</p>
</div>
</div>



<div id="outline-container-org8ebdcd6" class="outline-4">
<h4 id="org8ebdcd6"><span class="section-number-4">1.6.3.</span> 生命周期</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
在C/C++语言，或者其他语言中，一个变量的生命周期，包括了作用域和存储期两个方面。
</p>
<ol class="org-ol">
<li>作用域：在程序文本中的可见区域。（为什么要有作用域呢？，这涉及到语言学方面。）在编译期。</li>
<li>存储期：在函数内的自动存储期、全局的静态存储期、动态存储期、线程存储期。在运行期。</li>
</ol>

<p>
变量在哪个作用域实例化，那么它的生命区间，就在哪个作用域。那么变量就拥有所有权。所有权只有借用或者转移。借用就是<a href="#org0058f0c">引用</a>。    
生命周期就是解决悬空引用，什么是就是只有引用，没有实际的数据。就像一个悬空的针，为什么会导致悬空，就是因为rust，会在作用域结尾添加drop函数，
就是free函数。
</p>

<p>
借用检查器：
</p>


<p>
静态生命周期(static lifetime)：'static
</p>
</div>
</div>
</div>
<div id="outline-container-org1463ef7" class="outline-3">
<h3 id="org1463ef7"><span class="section-number-3">1.7.</span> third party</h3>
<div class="outline-text-3" id="text-1-7">
<p>
使用第三方包，使用参数flags，如下：
</p>

<div class="org-src-container">
<pre class="src src-rust">use rand::Rng;
 fn main(){
       let secret=rand::thread_rng().gen_range(1..=100);
     println!("the secret number is:{secret}");
 }
</pre>
</div>

<pre class="example">
the secret number is:28
</pre>
</div>
</div>



<div id="outline-container-orgc3a9af5" class="outline-3">
<h3 id="orgc3a9af5"><span class="section-number-3">1.8.</span> <span class="todo TODO">TODO</span> todo <span class="timestamp-wrapper"><span class="timestamp">&lt;2024-03-01 Fri&gt;</span></span></h3>
<div class="outline-text-3" id="text-1-8">
<p>
1.对比 C++和rust的多态
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: sunxiebin</p>
<p class="date">Created: 2024-04-29 Mon 16:48</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
